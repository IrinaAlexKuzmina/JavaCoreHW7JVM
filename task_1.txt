public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}

0. JVM запускает подсистему загрузки классов (или ClassLoader), которая анализирует файл с байт-кодом, выявляя все упоминания классов, в данном примере это будет JvmComprehension, String, Object, Integer, System. ClassLoader просматривает загружены ли классы в MetaSpace (раздел ОЗУ)- он же далее кэш. Есть несколько уровней иерархии загрузчиков классов, начиная с пользовательских загрузчиков, далее загрузчик приложения, загрузчик платформы, базовый загрузчик стандартных классов. Базовый загрузчик является родителем для остальных. Загрузка классов происходит по принципу ленивой загрузки, т.е. класс загружается только по мере того как встречается в коде конкретная ссылка на него. Поиск класса в ОЗУ начинается с пользовательских загрузчиков, если они есть и далее до базового. 
1. (Картинка 1) JVM смотрит есть ли класс JvmComprehension в кеше памяти в пользовательском загрузчике и далее до базового. Не находит. Каждый загрузчик имеет собственную директорию, где он ищет файл, когда пытается его загрузить. Так управление перешло к базовому загрузчику класса. Bootstrap ClassLoader не найдя в своем кэше класс JvmComprehension, пытается его загрузить по своей директории. Неудачно, данного класса там нет. Тогда управление принимает его дочерний класс Platform ClassLoader, также пытается загрузить файл, но уже по своей директории. И так далее до уровня Application ClassLoader. Класс найден, происходит загрузка. По такому же принципу загружаются остальные классы String, Object, Integer, System. Только все они загрузятся базовым загрузчиком. На этом этапе в память загружается общая информация о классе, его методы, статические переменные, константы, поля и т.д. При этом происходят разные проверки на валидируемость ссылок и т.д. Происходит инициализация класса, статическим полям присваиваются значения.
//1 (Картинка 2) Дальше в Stack Memory на каждый метод создается отдельный фрейм (отдельная область памяти, выделенная для метода). Сейчас по коду у нас это метод main, с него начинается исполнение. Во фрейм записывается информация о входных параметрах метода. В стеке хранятся значения примитивных переменных или ссылки на объекты, а также простые массивы. В нашем случае входящий параметр состоит из массива объектов класса String, это значит в стэке будет хранится массив из ссылок на объекты класса String (????? Почему никто не пишет о том как происходит обработка массива args в методе main ???? - Написала отсебятину поэтому). Дальше идет инициализация примитивной переменной, ей присваивается значение 1.  
//2 (Картинка 3) Создается новая переменная o класса Object. Так как переменная является объектом, а все объекты у нас хранятся в куче (heap), то в стеке хранится ссылка на объект, который находится в куче.
//3 (Картинка 3) Создается новая переменная ii класса Integer. Так как переменная является объектом, а все объекты у нас хранятся в куче (heap), то в стеке хранится ссылка на объект, который находится в куче. (все аналогично пред пункту)
//4 (Картинка 4) Происходит вызов нового метода printAll. В этот момент в нашем стэке создается второй фрейм для нового метода. При создании нового фрейма происходит запоминание адреса вызова (чтобы вернуться назад после выполнения метода), входные переменные копируются по значению. Значением ссылочной переменной по сути является ссылка, в этом случае в памяти появляются новые переменные с указанием на переданные ссылки. 
//5 (Картинка 4) Создается новая переменная uselessVar класса Integer. Так как переменная является объектом, а все объекты у нас хранятся в куче (heap), то в стеке хранится ссылка на объект, который находится в куче. 
//6 (Картинка 5) Чтобы вызвать System.out.println нужно для начала вычислить параметр, передаваемый в этот метод, поэтому я предполагаю, что сначала должен создасться фрейм для System.out.println, который в свою очередь породит создания фрейма toString() с запоминанием адреса возврата. Метод toString() возвращает строку во входной параметр System.out.println - так как это неявная переменная, назовем ее _str1. Также из-за скрытой реализации метода непонятно, то ли строка будет лежать в кеш-пулинге, то ли в общем хипе (поэтому нарисованы тонкие стрелочки).
//6 (Картинка 6) Когда вышли из метода toString() мы вернулись по запомненному адресу ниже в стек, а фрейм, что открывался для toString(), удалился из стека. На этом этапе происходит неявное преобразование разных типов данных к строкам - тоже по сути разные методы, но для простоты опустим этот момент. В конечном итоге у нас получится одна результирующая строкаб назовем ее _str2. Именно ее у нас и выведет метод System.out.println. Также на этом этапе удалются неиспользуемые элементы из кучи. Это строка из пред пункта, полученная через метод toString(), вызванного над объектом o (подсвечена цветом).
//7 (Картинка 7) printAll закончил свою работу и управление вернулось обратно в main, откуда создался новый фрейм для метода System.out.println, выводящий строку "finished", дадим ей условное название _str3. На этом программа заканчивает свое действие. JVM будет по стеку передвигаться вниз, из System.out.println в метод main, освобождая в хипе ненужные ресурсы. Сборщик мусора включается с определенной периодичностью, полностью останавливая выполнение программы, просматривая элементы по достижимости ссылок, начиная свой путь с элементов из стека, ссылающихся на хип.

